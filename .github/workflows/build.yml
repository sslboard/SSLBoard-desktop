name: Build

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build-windows:
    name: Build Windows
    if: false  # Temporarily disabled
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      
      - name: Setup vcpkg
        shell: pwsh
        run: |
          if (-not (Test-Path C:\vcpkg\vcpkg.exe)) {
            git clone https://github.com/Microsoft/vcpkg.git C:\vcpkg
            C:\vcpkg\bootstrap-vcpkg.bat
          }
      
      - name: Cache vcpkg installed packages
        uses: actions/cache@v4
        id: vcpkg-cache
        with:
          path: C:\vcpkg\installed
          key: vcpkg-installed-openssl-x64-windows-static-md-v1
          restore-keys: |
            vcpkg-installed-openssl-x64-windows-static-md-v1
            vcpkg-installed-
      
      - name: Install OpenSSL via vcpkg
        if: steps.vcpkg-cache.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          echo "Installing OpenSSL via vcpkg. vcpkg will use its binary cache if available (faster), otherwise will build from source (~6-7 minutes)"
          C:\vcpkg\vcpkg install openssl:x64-windows-static-md
      
      - name: Setup OpenSSL environment
        shell: pwsh
        run: |
          $installed = "C:\vcpkg\installed\x64-windows-static-md"
          echo "VCPKG_ROOT=C:\vcpkg" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "OPENSSL_DIR=$installed" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "OPENSSL_LIB_DIR=$installed\lib" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "OPENSSL_INCLUDE_DIR=$installed\include" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build Tauri app for Windows
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: .
          tagName: ${{ github.ref_name }}
          releaseName: 'SSLBoard Desktop ${{ github.ref_name }}'
          releaseBody: 'See the assets to download this version and install.'
          releaseDraft: false
          prerelease: false

  build-macos:
    name: Build macOS
    runs-on: macos-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      
      - name: Install dependencies
        run: npm ci
      
      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.APPLE_CERTIFICATE_BASE64 }}" ]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_BASE64")
          fi
          
          if [ -z "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" ]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_PASSWORD")
          fi
          
          if [ -z "${{ secrets.APPLE_SIGNING_IDENTITY }}" ]; then
            MISSING_SECRETS+=("APPLE_SIGNING_IDENTITY")
          fi
          
          if [ -z "${{ secrets.APPLE_TEAM_ID }}" ]; then
            MISSING_SECRETS+=("APPLE_TEAM_ID")
          fi
          
          if [ -z "${{ secrets.APPLE_ID }}" ]; then
            MISSING_SECRETS+=("APPLE_ID")
          fi
          
          if [ -z "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" ]; then
            MISSING_SECRETS+=("APPLE_APP_SPECIFIC_PASSWORD")
          fi
          
          if [ -z "${{ secrets.KEYCHAIN_PASSWORD }}" ]; then
            MISSING_SECRETS+=("KEYCHAIN_PASSWORD")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "❌ ERROR: Missing required GitHub secrets for code signing and notarization:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please configure all required secrets in:"
            echo "  Settings → Secrets and variables → Actions"
            exit 1
          fi
          
          echo "✅ All required secrets are configured"
      
      - name: Import code signing certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH" 2>/dev/null || \
          echo "$APPLE_CERTIFICATE_BASE64" | base64 -D > "$CERTIFICATE_PATH"
          
          # Remove keychain if it already exists (from previous run or retry)
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "Removing existing keychain..."
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Ensure codesign can find identities (keep login keychain in search list too)
          LOGIN_KEYCHAIN=$(security login-keychain | tr -d '"')
          security list-keychains -d user -s "$KEYCHAIN_PATH" "$LOGIN_KEYCHAIN"
          security default-keychain -s "$KEYCHAIN_PATH"
          
          # Import certificate to keychain
          security import "$CERTIFICATE_PATH" -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # List available identities
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"
          
          # Store keychain path for next step
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
      
      - name: Build Tauri app for macOS
        uses: tauri-apps/tauri-action@v0
        id: build
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
        with:
          projectPath: .
          tagName: ${{ github.ref_name }}
          releaseName: 'SSLBoard Desktop ${{ github.ref_name }}'
          releaseBody: 'See the assets to download this version and install.'
          releaseDraft: false
          prerelease: false
      
      - name: Debug build outputs
        run: |
          echo "Checking for build outputs..."
          echo "Working directory: $(pwd)"
          echo ""
          echo "Contents of src-tauri/target/release/bundle:"
          ls -la src-tauri/target/release/bundle/ 2>/dev/null || echo "Directory does not exist"
          echo ""
          echo "Searching for .app files:"
          find src-tauri/target/release -name "*.app" -type d 2>/dev/null || echo "No .app files found"
          echo ""
          echo "Searching for .dmg files:"
          find src-tauri/target/release -name "*.dmg" -type f 2>/dev/null || echo "No .dmg files found"
      
      - name: Notarize macOS DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
        run: |
          # Debug: List bundle directory structure
          echo "Searching for app bundle and DMG..."
          find src-tauri/target/release/bundle -type f -o -type d | head -20 || true
          
          # Find the built app bundle and DMG (search in multiple possible locations)
          APP_BUNDLE=$(find src-tauri/target/release/bundle -name "*.app" -type d | head -1)
          DMG_FILE=$(find src-tauri/target/release/bundle -name "*.dmg" -type f | head -1)
          
          # If not found, try searching in dmg subdirectory
          if [ -z "$DMG_FILE" ]; then
            DMG_FILE=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" -type f | head -1)
          fi
          
          # If still not found, try searching in macos subdirectory
          if [ -z "$APP_BUNDLE" ]; then
            APP_BUNDLE=$(find src-tauri/target/release/bundle/macos -name "*.app" -type d | head -1)
          fi
          
          echo "Found APP_BUNDLE: $APP_BUNDLE"
          echo "Found DMG_FILE: $DMG_FILE"
          
          if [ -z "$DMG_FILE" ]; then
            echo "❌ ERROR: DMG not found. Cannot proceed with notarization."
            echo "DMG_FILE: ${DMG_FILE:-NOT FOUND}"
            echo ""
            echo "Build artifacts must be present for notarization. Check the build step output above."
            exit 1
          fi
          
          # Optional: Notarize the app bundle if present (useful for direct .app distribution),
          # but do not block DMG notarization when only a DMG is produced.
          if [ -n "$APP_BUNDLE" ]; then
            echo "Notarizing app bundle: $APP_BUNDLE..."
            ZIP_PATH=$(mktemp -t sslboard-notarize).zip
            ditto -c -k --keepParent "$APP_BUNDLE" "$ZIP_PATH"
            
            xcrun notarytool submit "$ZIP_PATH" \
              --apple-id "$APPLE_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --wait
            
            xcrun stapler staple "$APP_BUNDLE"
            xcrun stapler validate "$APP_BUNDLE"
            rm "$ZIP_PATH"
            echo "App bundle notarization complete!"
          else
            echo "⚠️  No .app bundle found on disk; proceeding with DMG-only notarization."
          fi
          
          # Then notarize the DMG
          echo "Notarizing DMG: $DMG_FILE..."
          xcrun notarytool submit "$DMG_FILE" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait
          
          xcrun stapler staple "$DMG_FILE"
          xcrun stapler validate "$DMG_FILE"
          echo "DMG notarization complete!"
      
      - name: Upload notarized DMG
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Find the notarized DMG (search in multiple possible locations)
          DMG_FILE=$(find src-tauri/target/release/bundle -name "*.dmg" -type f | head -1)
          
          # If not found, try searching in dmg subdirectory
          if [ -z "$DMG_FILE" ]; then
            DMG_FILE=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" -type f | head -1)
          fi
          
          if [ -z "$DMG_FILE" ]; then
            echo "❌ ERROR: Notarized DMG not found. Cannot upload to release."
            exit 1
          fi
          
          echo "Uploading notarized DMG: $DMG_FILE"
          gh release upload "${{ github.ref_name }}" "$DMG_FILE" --clobber
          echo "✅ DMG uploaded to release!"

      - name: Cleanup signing keychain
        if: always()
        env:
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
        run: |
          if [ -n "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi
